# SwerveDriveCode: Builder & Driver Reference

---

## Table of Contents
- [Project Overview](#project-overview)
- [Key Files & Structure](#key-files--structure)
- [Robot Features](#robot-features)
- [Robot Modes & Capabilities](#robot-modes--capabilities)
- [Swerve System: Where & How](#swerve-system-where--how)
- [Driver Controls Cheat Sheet](#driver-controls-cheat-sheet)
- [Calibration & Offsets](#calibration--offsets)
- [Alliance & Field-Centric Driving](#alliance--field-centric-driving)
- [Telemetry & Logging](#telemetry--logging)
- [Simulation Support](#simulation-support)
- [Build, Deploy, & Simulate](#build-deploy--simulate)
- [Troubleshooting & FAQ](#troubleshooting--faq)
- [Hardware Mapping Appendix](#hardware-mapping-appendix)

---

## Project Overview
This project is a full-featured swerve drive robot codebase for FRC, designed for reliability, clarity, and ease of use by both programmers and builders. It supports field-centric driving, robust calibration, telemetry, and simulation.

---

## Key Files & Structure
- **`src/main/java/frc/robot/Robot.java`**: Main robot lifecycle (handles mode switching, command scheduling)
- **`src/main/java/frc/robot/RobotContainer.java`**: Sets up subsystems, driver controls, and default behaviors
- **`src/main/java/frc/robot/generated/TunerConstants.java`**: All hardware IDs, module offsets, and geometry
- **`src/main/java/frc/robot/subsystems/CommandSwerveDrivetrain.java`**: Swerve drivetrain implementation
- **`src/main/java/frc/robot/Telemetry.java`**: Telemetry and dashboard logging
- **`vendordeps/`**: Vendor library configs (CTRE, WPILib)
- **`tuner-project.json`**: Hardware mapping and offsets (generated by CTRE Tuner X)

---

## Robot Features
- **Swerve drive** with field-centric control (robot always drives relative to the field, not its own frame)
- **Automatic alliance perspective**: "Forward" always matches the field, even when switching sides
- **Driver controls**: Xbox-style controller with intuitive mapping (see below)
- **Live wheel pointing**: Hold B and use the left stick to point all wheels in any direction (not a calibration, just a maneuvering tool)
- **Brake mode**: Hold A to lock wheels in a defensive stance
- **Heading reset**: Left bumper sets current facing as "forward" for field-centric driving
- **SysId routines**: Back/Start + X/Y combos run motor characterization for tuning
- **Telemetry**: Robot pose, wheel angles/speeds, odometry, and more to dashboard and log
- **Simulation support**: Fast internal sim loop for realistic off-robot testing
- **Robust calibration**: Each module uses an absolute encoder and stored offset for true zeroing

---

## Robot Modes & Capabilities
| Mode         | What the Robot Can Do                                                                 |
|--------------|--------------------------------------------------------------------------------------|
| **Disabled** | Motors idle safely; field-centric heading and alliance perspective are set            |
| **Teleop**   | Full driver control: swerve drive, wheel pointing, brake, heading reset, telemetry   |
| **Autonomous**| (Default: no auto) - can be extended; will print "No autonomous command configured"  |
| **Test**     | Cancels all running actions for safe subsystem testing                               |
| **Simulation**| Fast sim loop, full telemetry, field-centric and wheel logic all work in sim         |

---

## Swerve System: Where & How
- **Hardware/geometry setup**: [`TunerConstants.java`](src/main/java/frc/robot/generated/TunerConstants.java)
  - IDs for drive/steer motors, encoders, gyro, gear ratios, wheel radius, chassis size, and module offsets
- **Drivetrain implementation**: [`CommandSwerveDrivetrain.java`](src/main/java/frc/robot/subsystems/CommandSwerveDrivetrain.java)
  - Handles field-centric logic, alliance perspective, simulation, and tuning
- **Driver controls & default command**: [`RobotContainer.java`](src/main/java/frc/robot/RobotContainer.java)
  - Sets up the swerve drive to respond to sticks every 20ms in teleop
- **Lifecycle & scheduling**: [`Robot.java`](src/main/java/frc/robot/Robot.java)
  - Keeps everything running and responsive in all modes

**When does swerve run?**
- As soon as the robot starts, the swerve drive is set to respond to the controller sticks (teleop)
- Button actions (A, B, left bumper, etc.) are active during teleop (and some while disabled)
- Swerve logic is always running in the background, updating every 20ms

---

## Driver Controls Cheat Sheet
| Control         | Action                                                                 |
|-----------------|-----------------------------------------------------------------------|
| Left stick Y    | Forward/backward                                                      |
| Left stick X    | Strafe left/right                                                     |
| Right stick X   | Rotate left/right                                                     |
| **A**           | Brake mode (hold wheels in defensive stance)                          |
| **B**           | Point all wheels in the direction of the left stick (live, not preset)|
| Left bumper     | Reset field-centric heading to current robot orientation              |
| Back + Y        | SysId dynamic test (forward)                                          |
| Back + X        | SysId dynamic test (reverse)                                          |
| Start + Y       | SysId quasistatic test (forward)                                      |
| Start + X       | SysId quasistatic test (reverse)                                      |

---

## Calibration & Offsets
- **How does the robot know wheel angles?**
  - Each swerve module has an absolute encoder (CTRE CANcoder or similar)
  - Each module’s “straight ahead” offset is measured and stored in [`TunerConstants.java`](src/main/java/frc/robot/generated/TunerConstants.java)
  - On boot, the robot reads each encoder and subtracts the offset so it always knows true zero
- **When to recalibrate?**
  - Only if you change hardware or re-clock a module
  - Update offsets in `TunerConstants.java` (see `kFrontLeftEncoderOffset`, etc.)
- **Field-centric heading**
  - Uses the gyro (Pigeon2) to know robot orientation
  - Press left bumper to reset “forward” to the current facing

---

## Alliance & Field-Centric Driving
- The robot automatically flips “forward” to match the red/blue alliance
- This ensures driver controls always feel the same, no matter which side you’re on
- Field-centric heading can be reset at any time with the left bumper

---

## Telemetry & Logging
- Robot pose (position and heading) is sent to the dashboard and log
- Module angles and speeds (actuals and targets) are visualized and logged
- Odometry frequency and other diagnostics are available
- All data is logged for post-run analysis (CTRE SignalLogger)

---

## Simulation Support
- Fast internal simulation loop for realistic drive tuning and testing off-robot
- Telemetry and field-centric logic work in simulation just like on the real robot

---

## Build, Deploy, & Simulate
**Windows PowerShell commands:**

```powershell
# Build the code
./gradlew build

# Simulate the robot (with GUI)
./gradlew simulateJava

# Deploy to the roboRIO
./gradlew deploy
```

- Make sure you have WPILib and CTRE Phoenix 6 installed
- See `build.gradle` for more details

---

## Troubleshooting & FAQ
- **Wheels point wrong at boot?**
  - Check module offsets in `TunerConstants.java`
- **Driving feels rotated?**
  - Press left bumper to reset field heading
- **No robot movement?**
  - Check CAN IDs, power, and that all modules are plugged in
- **Want to change hardware IDs or geometry?**
  - Update `tuner-project.json` and regenerate `TunerConstants.java`
- **No autonomous?**
  - Add your auto routine in `RobotContainer.getAutonomousCommand()`

---

## Hardware Mapping Appendix
- **Gyro**: Pigeon2, CAN ID 13
- **Modules:**
  - Front Left: Drive 1, Steer 2, Encoder 9
  - Front Right: Drive 3, Steer 4, Encoder 10
  - Back Left: Drive 5, Steer 6, Encoder 11
  - Back Right: Drive 7, Steer 8, Encoder 12
- **Wheel radius**: 4 inches
- **Track width/length**: 25 in x 25 in
- **Offsets**: See `TunerConstants.java` for each module’s encoder offset
- **All other geometry and tuning**: `TunerConstants.java` and `tuner-project.json`

---

For more help, see comments in each file or ask your programming lead!
